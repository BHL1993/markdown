Redis过期策略
1、定时清理
    在设置键值过期时间时，创建一个定时事件，当过期时间到达时，由事件处理器自动执行键的删除操作。
        优点：保证内存可以被尽快地释放
        缺点：在 Redis 高负载的情况下或有大量过期键需要同时处理时，会造成 Redis 服务器卡顿，影响主业务执行
2、惰性清理
    不主动删除过期键，在每次查询时，判断键是否过期，如果过期，则删除并返回null。
        优点：不会占用过多的系统资源
        缺点：已经过期的key不会立即释放，导致空间利用率降低，造成一定程度上的空间浪费
3、定期清理
    每隔一段时间检查一次数据库，随机删除一些过期键。
    优缺点：介于定时清理与惰性清理之间的一种折中方法，即不会过多占用系统资源，也不会导致过期key一直占用内存空间。

Redis 使用的是惰性删除加定期删除的过期策略。


Redis管道技术
    Redis使用管道技术，将多个客户端命令整合到一起，发送给服务端，再一次返回给客户端，解决多个命令同时执行时的网络等待，提升Redis执行效率。

Redis内存淘汰策略
    Redis 内存淘汰机制指的是，当 Redis 运行内存已经超过 Redis 设置的最大内存之后，将采用什么策略来删除符合条件的键值对，以此来保障 Redis 高效的运行。
    1、不淘汰。当内存不足时，新增操作会报错，Redis 默认内存淘汰策略；
    2、随机淘汰任意键值；
    3、随机淘汰设置了过期时间的任意键值；
    4、淘汰整个键值中最久未使用的键值；
    5、淘汰所有设置了过期时间的键值中最久未使用的键值；
    6、优先淘汰更早过期的键值。

Redis分布式锁
1、setNx和expire的原子性问题
通过lua脚本或者带超时时间的set命令解决
2、分布式锁执行超时的问题
解决方案1：把执行比较耗时的任务不要放到加锁的方法体内，锁内的方法尽量控制执行时长
解决方案2：过期时间设置的长一点，正常情况下，锁用完之后，手动删除
3、锁被误删的问题
解决方案：在使用set命令创建锁的时候，给value值设置一个归属标识。每次在删除之前，先判断该归属标识是不是属于当前线程，如果属于当前线程则再删除。

Bloom过滤器
数据结构：二进制数组，只保存0、1
添加数据：使用多个hash函数，将key生成多个hash值，并将每个hash值指向的bit位置为1
查询数据：使用上述hash函数，将key生成多个hash值，判断每个hash值指向的bit位是否为1，只要有一个bit不为1，则代表该数据不存在。如果所有位置的bit都为1，则代表数据可能存在。

缓存穿透
场景：指针对一定不存在的数据进行的查询，所有的查询请求会直接打到DB，在恶意请求的情况下，会将DB打挂。
解决方案1：查询DB后，如果数据不存在，则在redis中写null，下次请求直接便可直接返回。问题：null过期时间不易设置，容易造成返回结果不准确。
解决方案2：在redis与DB的中间层，增加Bloom过滤器，可以确保不存在的数据直接返回，且不会使得请求直接打到DB。

缓存击穿
场景：某个Key在过期后，瞬间出现了有大量的请求，此时所有请求会直接打到DB，严重影响DB性能
解决方案1：在缓存查询结果为空，准备查询DB之前，加一个分布式锁，只有拿到锁的请求才可以请求DB，并写入缓存。没拿到锁的请求自旋后重新查询缓存。
解决方案2：设置缓存永不过期。需要注意数据更新后，要及时更新

缓存雪崩
场景：多个key在同一时间集中过期，导致大量请求直接打到DB
解决方案：为不同的key设置超时时间时，加上一个随机数，避免同时过期


Redis集群方案
1、主从模式
    优点：
        1、master数据自动同步到slave，可以进行读写分离，分担master读压力
        2、master、slave之间的同步以非阻塞方式进行，数据同步期间仍然可以处理请求
    缺点：
        1、不具备自动容错与恢复功能
        2、难以支持在线扩容，Redis容量受限于单机配置
2、哨兵模式
    优点：
        1、master数据自动同步到slave，可以进行读写分离，分担master读压力
        2、master、slave之间的同步以非阻塞方式进行，数据同步期间仍然可以处理请求
        3、哨兵模式下，master挂掉可以自动进行切换，系统可用性更高
    缺点：
        1、难以支持在线扩容，Redis容量受限于单机配置
        2、额外的资源来启动sentinel进程，实现相对复杂一点
        3、Cluster模式
    优点：
        1、无中心架构，数据按照slot分布在多个节点。
        2、只需要连接集群中的任意一个节点，就可以获取到其他节点的数据。
        3、节点可动态添加或删除
        4、能够实现自动故障转移
    缺点：
        1、客户端实现复杂，需要缓存Slot映射信息
        2、salve充当冷备，不能缓解读压力
    Hash槽：
        Redis Cluster默认分配了16384个slot，每个节点分别管理一部分的slot。Key和slot的映射方法：CRC16(key) % 16384